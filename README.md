# cyfrin-advanced-foundry-merkle-airdrop

This project is a section of the [Cyfrin Foundry Solidity Course](https://github.com/Cyfrin/foundry-full-course-cu?tab=readme-ov-file#advanced-foundry-section-4-foundry-merkle-airdrop-and-signatures).

An airdrop is a strategy to distribute tokens or assets to a specific group of people or community.
This project airdrops tokens to users who can prove they are in a merkle tree.

## What is a Merkle tree?

* A Merkle tree is a binary tree where:
  * Each leaf node represents the hash of a data element (in this case, wallet addresses and amounts to claim).
  * Non-leaf nodes are hashes of their child nodes.
  * The root node represents the final hash that summarizes the entire tree.

### Example of a Merkle tree of 4 leaf nodes

```
        Root
       /    \
     H12     H34
    /  \     /  \
   H1  H2   H3  H4
   L1  L2   L3  L4
```

Let's take `L1`. The Merkle Proof for `L1` is [`H2`, `H34`] i.e. the list of sibling hashes along the path from the leaf node to the root.

### Check inclusion

To check if a leaf node is in the Merkle tree, we need to calculate the node hash and we need the related Merkle proof.
Then we calculate the hashes up to the root and if the calculated root is identical to the stored root, we know that the leaf node is in the Merkle tree.

* Searching for inclusion in an unordered array has a linear complexity of `O(n)`
* Verifying inclusion in a Merkle tree involves only `log(n)` operations

where `n` is lenght of the array / number of leaf nodes in the Merkle tree.

> With the usage of Merkle trees we only need to store the Merkle root onchain and the verification of inclusion is much cheaper.

## Implementation details

The whitelisted addresses and claimable token amounts and their related Merkle tree are stored offchain *(script/target/)* and generated by `GenerateInput` and `MakeMerkle` scripts respectively.

`ClaimAirdrop` script claims the airdropped tokens. It calls `MerkleAirdrop.claim` passing the claiming address and amount, the Merkle proof and the signature.

`BagelToken` is the ERC20 token that we are airdropping.

`MerkleAirdrop` is the airdrop contract using the [EIP-712](https://eips.ethereum.org/EIPS/eip-712) and [ERC-5267](https://eips.ethereum.org/EIPS/eip-5267) standards.

### Usage

#### MessageHash

To obtain the data for signing, use the `getMessageHash` function on the `MerkleAirdrop` contract. This function requires an account address, a `uint256` amount, and the Anvil node URL (`http://localhost:8545`).

```zsh
cast call <airdrop address> "getMessageHash(address,uint256)" <account address> <amount to claim> --rpc-url <rpc url>
```

##### Example on anvil

```zsh
cast call 0xe7f1725E7734CE288F8367e1Bb143E90bb3F0512 "getMessageHash(address,uint256)" 0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266 25000000000000000000 --rpc-url http://localhost:8545

0x7886453564f3abce484240ab03353027bde591090caf1f82ce22c3487afe9568
```

#### Signing

With the data ready for signing, use the `cast wallet sign` command. Include the `--no-hash` flag to prevent rehashing, as the message is already in bytes format. Also, use the `--private-key` flag with the first Anvil private key.

*NOTE:  When working on a testnet or using a real account, avoid using the private key directly. Instead, use the `--account` flag and your keystore account for signing.*

```zsh
cast wallet sign --no-hash <message hash> --private-key <private key>
```

##### Example on anvil

```zsh
cast wallet sign --no-hash 0x7886453564f3abce484240ab03353027bde591090caf1f82ce22c3487afe9568 --private-key 0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80

0x04209f8dfd0ef06724e83d623207ba8c33b6690e08772f8887a4eaf9a66b9182188938adea374fa542ad5ddde24bdc981f5e26a628e65fb425a68db8a938f6761c
```
